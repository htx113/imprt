% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/p_value.R
\name{pvalue_MI}
\alias{pvalue_MI}
\title{P-value Calculation with Multiple Imputation}
\usage{
pvalue_MI(
  null = c(0, 1),
  exposure_matrix,
  observation,
  obs_index = 1,
  impute_function = Imputation_sample,
  statistic = test_statistic
)
}
\arguments{
\item{null}{A vector of two values representing two exposure groups specified
in the null hypothesis.}

\item{exposure_matrix}{A matrix of dimension (number of units x number of
randomizations, i.e. assignments),
where each column represents different exposure assignments for
randomizations.}

\item{observation}{A numeric vector of observed values.}

\item{obs_index}{An integer indicating which column of the exposure_matrix is
correspondent to the observed exposure.}

\item{impute_function}{A function used for imputing missing values; defaults
to 'Imputation_sample'.}

\item{statistic}{A function used to calculate the test statistic; defaults to
'test_statistic', which is the absolute value of the difference-in-means test
statistic.}
}
\value{
A numeric value representing the mean of p-values computed via
multiple imputation.
}
\description{
P-value Calculation with Multiple Imputation
}
\examples{
# This example illustrates the use of the imputation-based randomization test
# (IRT) to calculate p-value in the setting of clustered interference.

library(imprt)
N <- 300
K <- 150
size <- N/K # size of clusters
K_treat <- floor(K/2) # number of treated clusters

# set of randomly selected treatment assignments
set.seed(113)
num_randomizations <- 1000
housestruct <- rep(N/K,K)

Z <- matrix(0, nrow=N, ncol=num_randomizations)
for (id_rand in 1:num_randomizations){
  W <- matrix(rep(0,N),nc=K)
  treat_cluster <- sort(sample(c(1:K),K_treat))
  treat_unit <- apply(as.matrix(housestruct[treat_cluster]),1,FUN = function(x){
    sample(c(1:x),1)
  })
  for (i in 1:K_treat){
    W[treat_unit[i],treat_cluster[i]] <- 1
  }
  Z[,id_rand] <- c(W)
}

exposure_matrix <- sapply(c(1:num_randomizations), function(i){
  Z_temp = Z[,i]
  f_temp = exposure(Z_temp,K)
  return(f_temp)
})

null <- c(0,1)

# generate potential outcomes
set.seed(113)
Ypot <- matrix(0, N, 2)
tau <- 0.5
Ypot[,1] <- rnorm(N, 0, 1)
Ypot[,2] <- Ypot[,1] + tau
Ypot <- data.frame(Ypot)
colnames(Ypot) <- c('exp0','exp1')
obs_index <- 1
exposure_obs <- exposure_matrix[,obs_index]
observation <- rep(NA,N)
observation[exposure_obs == 0] <-Ypot$exp0[exposure_obs == 0]
observation[exposure_obs == 1] <-Ypot$exp1[exposure_obs == 1]
set.seed(113)
pvalue_MI(null,exposure_matrix,observation,
          obs_index,impute_function=Imputation_sample,
          statistic=test_statistic)

}
